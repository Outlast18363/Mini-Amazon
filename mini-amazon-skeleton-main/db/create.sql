   DROP TABLE IF EXISTS users CASCADE;
   DROP TABLE IF EXISTS sellers CASCADE;
   DROP TABLE IF EXISTS transactions CASCADE;
   DROP TABLE IF EXISTS inventory CASCADE;
   DROP TABLE IF EXISTS categories CASCADE;
   DROP TABLE IF EXISTS products CASCADE;
   DROP TABLE IF EXISTS orders CASCADE;
   DROP TABLE IF EXISTS order_items CASCADE;
   DROP TABLE IF EXISTS order_sellers CASCADE;
   DROP TABLE IF EXISTS cart_items CASCADE;
   DROP TABLE IF EXISTS product_reviews CASCADE;
   DROP TABLE IF EXISTS seller_reviews CASCADE;
   DROP TABLE IF EXISTS review_helpful_votes CASCADE;
   DROP TABLE IF EXISTS message_threads CASCADE;
   DROP TABLE IF EXISTS messages CASCADE;
   DROP TABLE IF EXISTS coupons CASCADE;
   
-- Thomas (Account/Purchases)
CREATE TABLE IF NOT EXISTS users (
  id SERIAL PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  full_name TEXT NOT NULL,
  address TEXT NOT NULL,
  password_hash TEXT NOT NULL,
  balance NUMERIC(12,2) DEFAULT 0.00,
  created_at TIMESTAMP DEFAULT now()
);

-- assumptions:
-- emails unique
-- password stored as hash
-- USD dollars in NUMERIC


CREATE TABLE IF NOT EXISTS sellers (
  id SERIAL PRIMARY KEY,
  user_id INT UNIQUE NOT NULL REFERENCES users(id)
);


--------------------------------
-- Jameson (Products)
CREATE TABLE IF NOT EXISTS categories (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name VARCHAR(255) UNIQUE NOT NULL,
  parent_id INT REFERENCES categories(id)
);

CREATE TABLE IF NOT EXISTS products (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  description TEXT NOT NULL,
  image_url TEXT,
  category_id INT REFERENCES categories(id),
  created_by INT NOT NULL REFERENCES users(id),
  created_at TIMESTAMP DEFAULT (current_timestamp AT TIME ZONE 'UTC')
);


--------------------------------
-- Andy - Inventory/Order Fulfillment
CREATE TABLE IF NOT EXISTS inventory (
  seller_id INT NOT NULL REFERENCES sellers(id),
  product_id INT NOT NULL REFERENCES products(id),
  price_cents INT NOT NULL CHECK (price_cents >= 0),        -- unified price as cents
  quantity_on_hand INT NOT NULL CHECK (quantity_on_hand >= 0),
  updated_at TIMESTAMP DEFAULT now(),
  PRIMARY KEY (seller_id, product_id)
);
-- assumptions:
-- every seller is an existing user (no separate sellers table)
-- quantity_on_hand decreases at checkout (not at fulfillment)
-- override_price_cents lets each seller set a custom price;
-- if NULL, default to the product's base price
-- sellers cannot stock negative quantities

-- Indexes for inventory
CREATE INDEX IF NOT EXISTS idx_inventory_seller ON inventory(seller_id);
CREATE INDEX IF NOT EXISTS idx_inventory_product ON inventory(product_id);


--------------------------------
--- Johnson (Cart/Order)

CREATE TABLE IF NOT EXISTS cart_items (
   user_id INT NOT NULL REFERENCES users(id),
   product_id INT NOT NULL REFERENCES products(id),
   seller_id INT NOT NULL REFERENCES sellers(id),
   quantity INT NOT NULL CHECK (quantity >= 0),
   is_in_cart BOOLEAN NOT NULL DEFAULT TRUE,                -- TRUE=in cart, FALSE=saved for later
   PRIMARY KEY (user_id, product_id, seller_id, is_in_cart)
);
-- assumptions:
-- users don't want to purchase a product that is already in their cart


CREATE TABLE IF NOT EXISTS orders (
   order_id SERIAL PRIMARY KEY,
   buyer_id INT NOT NULL REFERENCES users(id),
   placed_at TIMESTAMP NOT NULL DEFAULT NOW(),
   shipping_address VARCHAR(400),
   order_fulfilled_at TIMESTAMP NULL,
   status TEXT NOT NULL DEFAULT 'PENDING' CHECK (status IN ('PENDING','PARTIAL','FULFILLED')),
   UNIQUE (order_id, buyer_id)
);
-- assumptions:
-- order_fulfilled_at is auto set by trigger only after all item lines are fulfilled


CREATE TABLE IF NOT EXISTS order_items (
   order_id INT NOT NULL REFERENCES orders(order_id),
   product_id INT NOT NULL REFERENCES products(id),
   seller_id INT NOT NULL REFERENCES sellers(id),
   quantity INT NOT NULL CHECK (quantity > 0),

   -- final, frozen-at-checkout values:
   unit_price_final_cents INT NOT NULL CHECK (unit_price_final_cents >= 0),
   discount_cents INT NOT NULL DEFAULT 0 CHECK (discount_cents >= 0),
   fulfilled_at TIMESTAMP NULL,                             -- Seller will mark when fulfilled
   PRIMARY KEY (order_id, product_id, seller_id)
);
-- assumptions:
-- discount_cents is calculated only at checkout
-- fulfilled_at is set by the seller


-- helper table to ensure buyer & seller in a message thread are actually participants in that order.
CREATE TABLE IF NOT EXISTS order_sellers (
  order_id INT NOT NULL REFERENCES orders(order_id),
  seller_id INT NOT NULL REFERENCES sellers(id),
  PRIMARY KEY (order_id, seller_id)
);

-- Populate order_sellers whenever new order_items are inserted
CREATE OR REPLACE FUNCTION populate_order_sellers()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO order_sellers(order_id, seller_id)
  VALUES (NEW.order_id, NEW.seller_id)
  ON CONFLICT DO NOTHING;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_populate_order_sellers ON order_items;
CREATE TRIGGER trg_populate_order_sellers
AFTER INSERT ON order_items
FOR EACH ROW
EXECUTE FUNCTION populate_order_sellers();

-- Trigger: update order status when all items fulfilled
-- We will update orders.status and orders.order_fulfilled_at
-- whenever order_items.fulfilled_at changes (or new items inserted).
-- Status semantics:
--   - PENDING: no line items fulfilled
--   - PARTIAL: some but not all fulfilled
--   - FULFILLED: all fulfilled (sets order_fulfilled_at)
CREATE OR REPLACE FUNCTION update_order_fulfillment()
RETURNS TRIGGER AS $$
DECLARE
  total_lines INT;
  fulfilled_lines INT;
BEGIN
  SELECT COUNT(*),
         COUNT(*) FILTER (WHERE fulfilled_at IS NOT NULL)
    INTO total_lines, fulfilled_lines
    FROM order_items
   WHERE order_id = NEW.order_id;

  IF fulfilled_lines = 0 THEN
     UPDATE orders
        SET status = 'PENDING',
            order_fulfilled_at = NULL
      WHERE order_id = NEW.order_id;
  ELSIF fulfilled_lines < total_lines THEN
     UPDATE orders
        SET status = 'PARTIAL',
            order_fulfilled_at = NULL
      WHERE order_id = NEW.order_id;
  ELSE
     UPDATE orders
        SET status = 'FULFILLED',
            order_fulfilled_at = now()
      WHERE order_id = NEW.order_id;
  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Trigger fires when we insert a new item (after checkout creates items)
-- or when a seller marks a line fulfilled by setting fulfilled_at.
DROP TRIGGER IF EXISTS trg_order_fulfillment_ins ON order_items;
CREATE TRIGGER trg_order_fulfillment_ins
AFTER INSERT ON order_items
FOR EACH ROW
EXECUTE FUNCTION update_order_fulfillment();

DROP TRIGGER IF EXISTS trg_order_fulfillment_upd ON order_items;
CREATE TRIGGER trg_order_fulfillment_upd
AFTER UPDATE OF fulfilled_at ON order_items
FOR EACH ROW
EXECUTE FUNCTION update_order_fulfillment();

-- Indexes for orders/order_items
CREATE INDEX IF NOT EXISTS idx_order_items_seller_fulfilled ON order_items(seller_id, fulfilled_at);
CREATE INDEX IF NOT EXISTS idx_orders_buyer_created ON orders(buyer_id, placed_at DESC);

-- assumptions:
-- sellers (users) mark individual order_items as FULFILLED
-- once all lines are fulfilled, the parent order is updated automatically
-- inventory is not modified by fulfillment

-- Now create transactions (references users and orders)
CREATE TABLE IF NOT EXISTS transactions (
  id SERIAL PRIMARY KEY,
  user_id INT NOT NULL REFERENCES users(id),
  amount NUMERIC(12,2) NOT NULL,
  order_id INT REFERENCES orders(order_id),
  created_at TIMESTAMP DEFAULT now()
);
-- assumptions
-- amount is positive for deposits, negative for withdrawals
-- there may be more transaction types in the future (including withdrawals, refunds, etc.)

--------------------------------
--- Feedback/Messages - Juliana

CREATE TABLE IF NOT EXISTS product_reviews (
    review_id SERIAL PRIMARY KEY,                           
    product_id INT NOT NULL REFERENCES products(id),       
    author_user_id INT NOT NULL REFERENCES users(id),      
    rating INT CHECK (rating BETWEEN 1 AND 5),
    title TEXT,
    body TEXT,
    created_at TIMESTAMP DEFAULT now(),
    updated_at TIMESTAMP DEFAULT now(),
    UNIQUE(author_user_id, product_id)
);

CREATE TABLE IF NOT EXISTS seller_reviews (
  review_id SERIAL PRIMARY KEY,
  seller_user_id INT NOT NULL REFERENCES sellers(id),
  author_user_id INT NOT NULL REFERENCES users(id),
  rating SMALLINT CHECK(rating BETWEEN 1 AND 5),
  title TEXT,
  body TEXT,
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  UNIQUE(author_user_id, seller_user_id)
);

-- update the 'updated_at' timestamp when reviews are touched
CREATE OR REPLACE FUNCTION touch_seller_review_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at := now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_touch_seller_rev
BEFORE UPDATE ON seller_reviews
FOR EACH ROW
EXECUTE FUNCTION touch_seller_review_updated_at();


CREATE TABLE IF NOT EXISTS review_helpful_votes (
  review_id INT NOT NULL REFERENCES product_reviews(review_id),
  voter_user_id INT NOT NULL REFERENCES users(id),
  created_at TIMESTAMP DEFAULT now(),
  PRIMARY KEY (review_id, voter_user_id)
);


CREATE TABLE IF NOT EXISTS message_threads (
  thread_id SERIAL PRIMARY KEY,
  order_id INT NOT NULL REFERENCES orders(order_id),
  seller_user_id INT NOT NULL REFERENCES sellers(id),
  buyer_user_id INT NOT NULL REFERENCES users(id),
  created_at TIMESTAMP DEFAULT now(),
  UNIQUE (order_id, seller_user_id, buyer_user_id),

  -- Enforce that buyer_user_id matches the order's buyer
  FOREIGN KEY (order_id, buyer_user_id) REFERENCES orders(order_id, buyer_id),
  -- Enforce that seller is actually a participant in the order
  FOREIGN KEY (order_id, seller_user_id) REFERENCES order_sellers(order_id, seller_id)
);


CREATE TABLE IF NOT EXISTS messages (
  message_id SERIAL PRIMARY KEY,
  thread_id INT NOT NULL REFERENCES message_threads(thread_id) ON DELETE CASCADE,
  sender_user_id INT NOT NULL REFERENCES users(id),
  body TEXT NOT NULL,
  sent_at TIMESTAMP DEFAULT now(),
  read_at TIMESTAMP DEFAULT NULL
);

-- Helpful indexes
CREATE INDEX IF NOT EXISTS idx_prod_rev ON product_reviews(product_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_sell_rev ON seller_reviews(seller_user_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_msg_time ON messages(thread_id, sent_at ASC);

--------------------------------
--- Promotions/Coupons

CREATE TABLE IF NOT EXISTS coupons (
    id SERIAL PRIMARY KEY,
    code VARCHAR(50) UNIQUE NOT NULL,
    discount_percent INT NOT NULL CHECK (discount_percent > 0 AND discount_percent <= 100),
    expiration_time TIMESTAMP NOT NULL,
    
    -- Scope: If both NULL, applies to entire cart.
    -- If product_id is set, applies to that product only.
    -- If category_id is set, applies to products in that category.
    product_id INT REFERENCES products(id),
    category_id INT REFERENCES categories(id),
    
    CHECK (NOT (product_id IS NOT NULL AND category_id IS NOT NULL)) -- Can't be both specific product AND specific category
);

CREATE INDEX IF NOT EXISTS idx_coupons_code ON coupons(code);

